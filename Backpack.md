# Динамическое программирование

Динамическое программирование — разбиение сложной задачи на небольшие подзадачи. Таким образом, достичь сложной цели становится проще. Решения подзадач сохраняются и используются в будущем для решения других задач. Это позволяет избежать повторных вычислений и значительно ускорить процесс.

## Задача о рюкзаке
Цель: Мы имеем рюкзак вместимостью W, в который нам необходимо положить k предметов имеющих вес w<sub>i</sub> и цену p<sub>i</sub>, так, чтобы стоимость была максимальной.

Как очевидно перебор всех возможных значение не является оптимальным.

## Краткое описание идеи

 Пусть A(k,s) - максимальная стоимость первых k предметов для рюкзака вместимостью s. Нулевые строчка и столбец заполнены нулями. 

 Затем для k-того предмета мы проверяем, помещается ли он в рюкзак с размером s. Если нет, то оставляем стоимость k-1-го предмета для рюкзака размером s.

 Если вмещается, то мы находим,чья стоимость больше: 
 1. Максимальная k-1-го предмета для рюкзака размером s.
 2. Стоимость k-того предмета плюс максимальная стоимость для k-1 предмета рюкзака размером s минус вес k-того.

## Восстановление ответа

Для того чтобы восстановить ответ нам необходимо пройтись по массиву с конца по следующему алгоритму.

Поиск ответов выполняется до тех пор, пока A[k][s] != 0.

Сравниваем стоимость k-того предмета со стоимостью k-1 предмета для рюкзака вместимостью s. Если они совпадают, то поднимаемся вверх и повторяем алгоритм.

Если они различны, значит k-ый предмет является одним из ответов. Сохраняем его, поднимаемся вверх и сдвигаемся влево на вес k-того элемента. Повторяем алгоритм. Теперь мы ищем ответ для рюказка размера s - w<sub>k</sub>.

## Пример решения задачи на c++

``` c++
#include <iostream>

struct item{
    unsigned int w = 0;
    unsigned int p = 0;
};

const int W = 13;
const int k = 5;
item items[k];

void find_answ(unsigned int A[k+1][W+1], int w, int k) {
    if (A[k][w] == 0) {
        return;
    }
    if (A[k][w] == A[k-1][w]) {
        find_answ(A,w,k-1);
    } else {
        std::cout << k << " ";
        find_answ(A, w - items[k-1].w, k-1);
    }
}

int main() {
    
    items[0] = {.w = 3, .p = 1};
    items[1] = {.w = 4, .p = 6};
    items[2] = {.w = 5, .p = 4};
    items[3] = {.w = 8, .p = 7};
    items[4] = {.w = 9, .p = 6};

    unsigned int A[k+1][W + 1] {0};

    for(int i = 1; i <= k; i++) {
        for (int j = 1; j <= W; j++) {
            if (j < items[i-1].w) {
                A[i][j] = A[i-1][j];
            } else {
                A[i][j] = std::max(A[i-1][j], A[i-1][j - items[i-1].w] + items[i-1].p);
            }
        }
    }

    for(int i = 0; i <= k; i++) {
        for (int j = 1; j <= W; j++) {

            std::cout << A[i][j] << " ";
        }
        std::cout << std::endl;
    }

    find_answ(A,W,k);
}
```