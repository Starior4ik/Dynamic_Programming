# Задача о максимальной подпоследовательности

Цель: Найти в массиве чисел строго возрастающую подпоследовательность наибольшей длины.

## Идея

Построим массив len, где len[i] — это длина наибольшей возрастающей подпоследовательности, оканчивающейся в элементе, с индексом i. 

Массив будем заполнять постепенно — сначала len[0], потом len[1] и т.д. Ответом на нашу задачу будет максимум из всех элементов массива len. 

Заполнение массива будет следующим: если len[i]=1, то искомая последовательность состоит только из числа
arr[i]. Если len[i]>1, то перед числом arr[i] в подпоследовательности стоит какое-то другое число. Переберем его: это может быть любой элемент arr[j]\(j=0...i−1), но такой, что arr[j]<
arr[i]. 

Пусть на каком-то шаге нам надо посчитать очередное len[i]. Все элементы массива len до него уже посчитаны. Значит наше len[i] мы можем посчитать следующим образом: len[i]=1+max<sub>j=0..i−1</sub> len[j] при условии, что arr[j]<a[i].

## Восстановление ответа

Пока что мы нашли лишь максимальную длину наибольшей возрастающей подпоследовательности, но саму ее мы вывести не можем. Для восстановления ответа заведем массив prev[0...n−1]
, где prev[i]
 будет означать индекс в массиве arr[]
, при котором достигалось наибольшее значение len[i]
. Для вывода ответа будем идти от элемента с максимальным значениям len[i]
 по его предкам.

 ### Сложность алгоритма O(n<sup>2</sup>).

## Пример кода
``` c++
#include <iostream>

int main() {
    int arr[8] = {5, 4, 1, 2, 5, 3, 6, 7};
    int len[8];
    int prev[8];

    for (int i = 0; i < 8; i++) {
        len[i] = 1;
        prev[i] = -1;
        for (int j = 0; j < i; j++) {  
            if (arr[j] < arr[i] && len[j] + 1 > len[i]) {
                len[i] = len[j] + 1;
                prev[i] = j;
            }
        }
    }

    int pos = 0;
    int max_len = len[0];
    for (int i = 0; i < 8; i++) {
        if (len[i] > max_len) {
            pos = i;
            max_len = len[i];
        }
    }
    std::cout << max_len << std::endl;  

    int answer[5];
    int last_ind = 4;
    while (pos != -1) {
        answer[last_ind] = arr[pos];
        pos = prev[pos];
        last_ind--;
    }

    for (int i = 0; i < 5; i++) {
        std::cout << answer[i] << " ";
    }
}
```

## Решение за O(n logn)

Для более быстрого решения данной задачи построим следующую динамику: пусть len[i]\(i=0...n) — число, на которое оканчивается возрастающая последовательность длины i
, а если таких чисел несколько — то наименьшее из них. Изначально мы предполагаем, что d[0]=−1, а все остальные элементы d[i]= ∞. Заметим два важных свойства этой динамики: d[i−1]⩽d[i], для всех i=1...n и каждый элемент a[i] обновляет максимум один элемент
d[j]. Это означает, что при обработке очередного a[i], мы можем за O(logn) c помощью двоичного поиска в массиве d найти первое число, которое больше либо равно текущего a[i] и обновить его.

## Восстановление ответа

Для восстановления ответа будем поддерживать заполнение двух массивов: pos и prev. В pos[i] будем хранить индекс элемента, на который заканчивается оптимальная подпоследовательность длины i, а в prev[i] — позицию предыдущего элемента для a[i].

## Пример кода

``` c++
#include <iostream>

int main() {
    int arr[8] = {5, 4, 1, 2, 5, 3, 6, 7};
    int len[8];
    int pos[8];
    int prev[8];
    int length = 0;

    pos[0] = -1;
    len[0] = -1;
    for (int i = 1; i < 8; i++) {
        len[i] = INF;
    }
       
    for (int i = 1; i < 7; i++) {
       int j = binary_search(len, arr[i]);
        if (len[j - 1] < arr[i] and arr[i] < len[j]) {
           len[j] = arr[i];
           pos[j] = i;
           prev[i] = pos[j - 1];
           length = std::max(length, j);
        }
    }

    int p = pos[length];
    int i = length - 1;
    int answer[8];
    while (p != -1) {
        answer[i] = arr[p];
        p = prev[p];
        i--;
    }
}
```