# Кузнечик

## Условие
Есть полоска 1xN, кузнечик стоит на первой клетке, он может прыгать вперед на 1, 2, 3 клетки. Сколько есть способов добраться от начальной клетки до последней?

## Идея

Задача очень похожа на нахождение N-го числа Фибоначчи, т.к. в N-ую клетку кузнечик может попасть из клеткок N-1, N-2, N-3.

Пусть F(x) - количество путей до точки N, тогда F(N) = F(N-1) + F(N-2) + F(N-3)

## Пример кода на c++

``` c++
#include <iostream>

const int N = 20;

int main() {
    int dp[N+1] {0};
    dp[1] = 1;
    dp[2] = 1;
    dp[3] = 2;
    for (int i = 4; i < N + 1; i++) {
        dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1];
    }
    std::cout << dp[20];
}
```

## Вариант с закрытыми клетками

Давайте изменим немного задачу: Теперь некоторые из клеток закрыты. То есть нам известно про конкретные клетки, что на них кузнечик прыгать не может. Тогда задача все еще решается так же, только нужно убедиться, что dp[x] = 0 для всех запрещенных x!

Также немного перепишем код, чтобы не писать отдельно случаи для 2 и 3, а также чтобы не писать в формуле сумму трех чисел (а представьте, что в задаче не 3, а 100). Будем инициализировать только dp[1]. А ко всем следующим значениям dp[i] будет прибавлять dp[i - k], где k = 1, 2, 3. Причем, если i - k < 1, то мы будем игнорировать такие клетки, и этим самым мы избавились от необходимости прописывать ответ для dp[2] и dp[3]

## Пример кода на c++

``` c++
#include <iostream>

const int N = 20;
int main() {
    int BAD_CELLS[] = {2, 3, 6, 13};

    int dp[N+1] {0};
    int is_bad[N+1] {0};
    for (int bad : BAD_CELLS) {
        is_bad[bad] = 1;
    }

    if (is_bad[1] != 1) {
        dp[1] = 1;
    } 

    for (int i = 2; i < N + 1; i++){
        if (is_bad[i] != 1) {
            for (int k = 1; k < 4; k++) {
                if (i - k >= 1) {
                    dp[i] += dp[i - k];
                }
            }
        }
    }

    std::cout << dp[20];    
}
```